<!-- Generated by docs/build.py from content.md -- do not edit directly -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PySyringe - Dependency Injection for Python</title>
  <meta name="description" content="An opinionated, zero-decorator dependency injection library for Python. Keep your domain clean, inject only at call sites.">
  <link rel="stylesheet" href="style.css">
</head>
<body>

<!-- Top navigation -->
<header class="topnav">
  <button class="menu-toggle" onclick="toggleSidebar()" aria-label="Toggle menu">&#9776;</button>
  <a href="#" class="topnav-brand"><img src="https://raw.githubusercontent.com/hugochinchilla/pysyringe/master/assets/logo.svg" alt="" width="28" height="28">PySyringe</a>
  <div class="topnav-links">
    <a href="https://github.com/hugochinchilla/pysyringe">GitHub</a>
    <a href="https://pypi.org/project/pysyringe/">PyPI</a>
    <select class="version-select" onchange="switchVersion(this.value)">
      <option value="../index.html">v2.0</option>
      <option value="index.html" selected>v1.5</option>
    </select>
    <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle dark mode"></button>
  </div>
</header>

<!-- Mobile overlay -->
<div class="overlay" onclick="toggleSidebar()"></div>

<div class="layout">

<!-- Sidebar -->
<aside class="sidebar">
  <nav>
    <div class="nav-section">
      <div class="nav-section-title">Getting Started</div>
      <a href="#introduction">Introduction</a>
      <a href="#installation">Installation</a>
      <a href="#quick-start">Quick Start</a>
    </div>
    <div class="nav-section">
      <div class="nav-section-title">Core Concepts</div>
      <a href="#container">The Container</a>
      <a href="#resolution">How Resolution Works</a>
      <a href="#factories">Factory Methods</a>
      <a href="#container-aware-factories">Container-Aware Factories</a>
      <a href="#inference">Constructor Inference</a>
      <a href="#aliases">Aliases</a>
      <a href="#blacklist">Blacklist</a>
    </div>
    <div class="nav-section">
      <div class="nav-section-title">Dependency Injection</div>
      <a href="#inject-decorator">The @inject Decorator</a>
      <a href="#provide">Providing Dependencies</a>
    </div>
    <div class="nav-section">
      <div class="nav-section-title">Singletons</div>
      <a href="#singleton">Global Singleton</a>
      <a href="#thread-local-singleton">Thread-Local Singleton</a>
    </div>
    <div class="nav-section">
      <div class="nav-section-title">Testing</div>
      <a href="#mocks">Mocks &amp; Overrides</a>
      <a href="#override-context">Override Context Manager</a>
      <a href="#legacy-mocks">Legacy Mock API</a>
    </div>
    <div class="nav-section">
      <div class="nav-section-title">Advanced</div>
      <a href="#thread-safety">Thread Safety</a>
      <a href="#resolution-cache">Resolution Cache</a>
      <a href="#optional-types">Optional &amp; Union Types</a>
      <a href="#errors">Error Handling</a>
    </div>
    <div class="nav-section">
      <div class="nav-section-title">Reference</div>
      <a href="#api-container">Container API</a>
      <a href="#api-singleton">Singleton API</a>
      <a href="#api-exceptions">Exceptions</a>
    </div>
  </nav>
</aside>

<!-- Main content -->
<main class="main">

<!-- Hero -->
<div class="hero">
  <h1>PySyringe</h1>
  <p class="tagline">An opinionated dependency injection library for Python.<br>Keep your domain clean. Inject only at call sites.</p>
  <div class="install-cmd">
    <span class="prompt">$</span> pip install pysyringe
  </div>
  <div class="feature-grid">
    <div class="feature-card">
      <h3>Zero-Decorator DI</h3>
      <p>Your domain classes stay free of framework annotations. Injection happens only at the infrastructure boundary.</p>
    </div>
    <div class="feature-card">
      <h3>Inference-Based Wiring</h3>
      <p>Auto-wire constructor dependencies from type hints. No registration boilerplate needed.</p>
    </div>
    <div class="feature-card">
      <h3>Thread-Safe by Design</h3>
      <p>Thread-local mocks, double-checked locking singletons, and per-thread instance caching built in.</p>
    </div>
    <div class="feature-card">
      <h3>Test-Friendly</h3>
      <p>Replace any dependency with a mock using context managers. Mocks never leak between threads.</p>
    </div>
    <div class="feature-card">
      <h3>Factory Support</h3>
      <p>Wire complex dependencies using factory methods. The container matches methods by return-type annotation.</p>
    </div>
    <div class="feature-card">
      <h3>Zero Dependencies</h3>
      <p>Pure Python. No external packages required. Works with Python 3.11+.</p>
    </div>
  </div>
</div>

<h2 id="introduction" class="section-anchor">Introduction</h2>
<p>PySyringe is a dependency injection container that does <strong>not</strong> require decorators on your domain classes. Instead of polluting your business logic with framework-specific annotations, PySyringe wraps only the views in your infrastructure layer&mdash;keeping your domain and application layer decoupled from the framework and the container.</p>
<p>The philosophy is simple: your domain code should not know that a DI container exists. Injection happens at the call site (HTTP handlers, CLI commands, message consumers) using the <code>@container.inject</code> decorator or explicit <code>container.provide()</code> calls.</p>
<h2 id="installation" class="section-anchor">Installation</h2>
<div class="highlight"><pre><span></span><code>pip install pysyringe
</code></pre></div>

<p>PySyringe requires <strong>Python 3.11</strong> or later and has no external dependencies.</p>
<h2 id="quick-start" class="section-anchor">Quick Start</h2>
<p>Here is a complete Flask application using PySyringe for dependency injection:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timezone</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">flask</span><span class="w"> </span><span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pysyringe.container</span><span class="w"> </span><span class="kn">import</span> <span class="n">Container</span>


<span class="c1"># 1. Define an interface and its implementation</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CalendarInterface</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">now</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">datetime</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Calendar</span><span class="p">(</span><span class="n">CalendarInterface</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">now</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">datetime</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">(</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span>


<span class="c1"># 2. Create and configure the container</span>
<span class="n">container</span> <span class="o">=</span> <span class="n">Container</span><span class="p">()</span>
<span class="n">container</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">CalendarInterface</span><span class="p">,</span> <span class="n">Calendar</span><span class="p">)</span>


<span class="c1"># 3. Inject dependencies at the call site</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;/now&quot;</span><span class="p">)</span>
<span class="nd">@container</span><span class="o">.</span><span class="n">inject</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_now</span><span class="p">(</span><span class="n">calendar</span><span class="p">:</span> <span class="n">CalendarInterface</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;now&quot;</span><span class="p">:</span> <span class="n">calendar</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()}</span>
</code></pre></div>

<p>That&rsquo;s it. The <code>CalendarInterface</code> and <code>Calendar</code> classes are plain Python&mdash;no decorators, no registration. The container resolves the dependency at the call site.</p>
<h2 id="container" class="section-anchor">The Container</h2>
<p>The <code>Container</code> class is the central piece of PySyringe. It manages dependency resolution, mocking, and injection.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">pysyringe.container</span><span class="w"> </span><span class="kn">import</span> <span class="n">Container</span>

<span class="c1"># Without a factory (inference-only)</span>
<span class="n">container</span> <span class="o">=</span> <span class="n">Container</span><span class="p">()</span>

<span class="c1"># With a factory object</span>
<span class="n">container</span> <span class="o">=</span> <span class="n">Container</span><span class="p">(</span><span class="n">MyFactory</span><span class="p">())</span>
</code></pre></div>

<p>The optional <code>factory</code> argument is any object whose public methods serve as factory functions. The container inspects these methods at initialization, indexing them by return-type annotation for O(1) lookup.</p>
<h2 id="resolution" class="section-anchor">How Resolution Works</h2>
<p>When you call <code>container.provide(SomeType)</code>, the container follows a strict resolution order:</p>
<ol>
<li><strong>Blacklist check</strong> &mdash; If the type was registered with <code>never_provide()</code>, resolution stops immediately.</li>
<li><strong>Mock store</strong> &mdash; Check the current thread&rsquo;s mock store. If a mock was registered via <code>use_mock()</code> or <code>override()</code>, return it.</li>
<li><strong>Alias lookup</strong> &mdash; If the type was registered with <code>alias()</code>, recursively resolve the mapped implementation type.</li>
<li><strong>Factory methods</strong> &mdash; Look up a factory method by return-type annotation. If found, call it and return the result. If the factory method accepts a <code>Container</code> parameter, the container passes itself.</li>
<li><strong>Constructor inference</strong> &mdash; Inspect the type&rsquo;s constructor, recursively resolve each parameter by its type hint, and construct the instance.</li>
</ol>
<p>If none of these strategies succeed, an <code>UnknownDependencyError</code> is raised.</p>
<div class="callout note">
<strong>Note</strong>
<p>Resolution does not cache instances. Each call to <code>provide()</code> creates a new instance (unless you use singleton helpers in your factory). The resolution <em>process</em> (parameter introspection, factory lookup) is cached for performance.</p>
</div>
<h2 id="factories" class="section-anchor">Factory Methods</h2>
<p>Factories give you full control over how dependencies are constructed. A factory is any object&mdash;the container discovers its public methods and indexes them by their return-type annotation.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">pysyringe.container</span><span class="w"> </span><span class="kn">import</span> <span class="n">Container</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pysyringe.singleton</span><span class="w"> </span><span class="kn">import</span> <span class="n">singleton</span>


<span class="k">class</span><span class="w"> </span><span class="nc">EmailSender</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">port</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">host</span> <span class="o">=</span> <span class="n">host</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span>


<span class="k">class</span><span class="w"> </span><span class="nc">DatabaseClient</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection_string</span> <span class="o">=</span> <span class="n">connection_string</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Factory</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">environment</span> <span class="o">=</span> <span class="n">environment</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_mailer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EmailSender</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">environment</span> <span class="o">==</span> <span class="s2">&quot;production&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">EmailSender</span><span class="p">(</span><span class="s2">&quot;smtp.example.org&quot;</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EmailSender</span><span class="p">(</span><span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">1025</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_database</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatabaseClient</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">singleton</span><span class="p">(</span><span class="n">DatabaseClient</span><span class="p">,</span> <span class="s2">&quot;postgresql://localhost/mydb&quot;</span><span class="p">)</span>


<span class="n">container</span> <span class="o">=</span> <span class="n">Container</span><span class="p">(</span><span class="n">Factory</span><span class="p">(</span><span class="s2">&quot;development&quot;</span><span class="p">))</span>

<span class="n">mailer</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="n">EmailSender</span><span class="p">)</span>       <span class="c1"># Uses factory method</span>
<span class="n">db</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="n">DatabaseClient</span><span class="p">)</span>        <span class="c1"># Uses factory + singleton</span>
</code></pre></div>

<p>Key rules for factory methods:</p>
<ul>
<li>Methods must be <strong>public</strong> (no leading underscore).</li>
<li>Methods must have a <strong>return-type annotation</strong>. The container matches requested types to factory methods by this annotation.</li>
<li>The method name does not matter&mdash;only the return type is used for matching.</li>
<li>Factory methods can use <code>singleton()</code> or <code>thread_local_singleton()</code> to control instance sharing.</li>
</ul>
<h3 id="container-aware-factories" class="section-anchor">Container-Aware Factories</h3>
<p>Factory methods can receive the <code>Container</code> itself as an argument. If a factory method declares a parameter typed as <code>Container</code>, the container passes itself when invoking the factory. This lets factories resolve sub-dependencies through the container, benefiting from inference, mocks, overrides, and aliases.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">pysyringe.container</span><span class="w"> </span><span class="kn">import</span> <span class="n">Container</span>


<span class="k">class</span><span class="w"> </span><span class="nc">AppConfig</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smtp_host</span> <span class="o">=</span> <span class="s2">&quot;smtp.example.org&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smtp_port</span> <span class="o">=</span> <span class="mi">25</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Factory</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_mailer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">:</span> <span class="n">Container</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EmailSender</span><span class="p">:</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="n">AppConfig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EmailSender</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">smtp_host</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">smtp_port</span><span class="p">)</span>


<span class="n">container</span> <span class="o">=</span> <span class="n">Container</span><span class="p">(</span><span class="n">Factory</span><span class="p">())</span>
<span class="n">mailer</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="n">EmailSender</span><span class="p">)</span>  <span class="c1"># Factory receives the container</span>
</code></pre></div>

<p>This is especially useful when:</p>
<ul>
<li>A factory needs dependencies that are themselves resolvable by the container (via inference or other factories).</li>
<li>You want factory-created objects to respect active <code>override()</code> or <code>use_mock()</code> replacements during tests.</li>
<li>You need to combine factory logic with the container&rsquo;s recursive resolution.</li>
</ul>
<p>Factory methods without a <code>Container</code> parameter continue to work exactly as before&mdash;called with no arguments.</p>
<h2 id="inference" class="section-anchor">Constructor Inference</h2>
<p>When no factory method or alias matches, PySyringe falls back to <strong>constructor inference</strong>. It inspects the class&rsquo;s <code>__init__</code> parameters, resolves each by type hint, and constructs the instance.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Logger</span><span class="p">:</span>
    <span class="k">pass</span>


<span class="k">class</span><span class="w"> </span><span class="nc">UserRepository</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logger</span><span class="p">:</span> <span class="n">Logger</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>


<span class="k">class</span><span class="w"> </span><span class="nc">UserService</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repo</span><span class="p">:</span> <span class="n">UserRepository</span><span class="p">,</span> <span class="n">logger</span><span class="p">:</span> <span class="n">Logger</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">repo</span> <span class="o">=</span> <span class="n">repo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>


<span class="n">container</span> <span class="o">=</span> <span class="n">Container</span><span class="p">()</span>
<span class="n">service</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="n">UserService</span><span class="p">)</span>

<span class="c1"># UserService was constructed with:</span>
<span class="c1">#   - a UserRepository (auto-constructed with its own Logger)</span>
<span class="c1">#   - a Logger</span>
</code></pre></div>

<p>Inference rules:</p>
<ul>
<li>Parameters <strong>must have type annotations</strong>. Unannotated parameters are skipped.</li>
<li><strong>Positional-only</strong> parameters are skipped.</li>
<li>Parameters with <strong>default values</strong> use the default if the type cannot be resolved.</li>
<li>Resolution is <strong>recursive</strong>&mdash;nested dependencies are resolved automatically.</li>
</ul>
<h2 id="aliases" class="section-anchor">Aliases</h2>
<p>Aliases map an interface (or abstract class) to a concrete implementation. When the container is asked to provide the interface type, it resolves the mapped implementation instead.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">NotificationService</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>


<span class="k">class</span><span class="w"> </span><span class="nc">SlackNotificationService</span><span class="p">(</span><span class="n">NotificationService</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>  <span class="c1"># send via Slack API</span>


<span class="n">container</span> <span class="o">=</span> <span class="n">Container</span><span class="p">()</span>
<span class="n">container</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">NotificationService</span><span class="p">,</span> <span class="n">SlackNotificationService</span><span class="p">)</span>

<span class="n">service</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="n">NotificationService</span><span class="p">)</span>
<span class="c1"># Returns a SlackNotificationService instance</span>
</code></pre></div>

<p>The implementation is constructed via inference, so its dependencies are resolved recursively. You don&rsquo;t need a factory method for aliased types.</p>
<h2 id="blacklist" class="section-anchor">Blacklist</h2>
<p>Use <code>never_provide()</code> to tell the container it should never attempt to construct certain types. This is useful for framework-provided types that should not be auto-wired.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">django.http</span><span class="w"> </span><span class="kn">import</span> <span class="n">HttpRequest</span><span class="p">,</span> <span class="n">HttpResponse</span>

<span class="n">container</span><span class="o">.</span><span class="n">never_provide</span><span class="p">(</span><span class="n">HttpRequest</span><span class="p">)</span>
<span class="n">container</span><span class="o">.</span><span class="n">never_provide</span><span class="p">(</span><span class="n">HttpResponse</span><span class="p">)</span>
</code></pre></div>

<p>When a blacklisted type appears as a constructor parameter, the container skips it. If the parameter has a default value, the default is used. If it doesn&rsquo;t, inference for the enclosing type fails gracefully.</p>
<h2 id="inject-decorator" class="section-anchor">The @inject Decorator</h2>
<p>The <code>@container.inject</code> decorator is the primary way to wire dependencies into your application&rsquo;s entry points (HTTP handlers, CLI commands, etc.).</p>
<div class="highlight"><pre><span></span><code><span class="nd">@app</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;/users&quot;</span><span class="p">)</span>
<span class="nd">@container</span><span class="o">.</span><span class="n">inject</span>
<span class="k">def</span><span class="w"> </span><span class="nf">list_users</span><span class="p">(</span><span class="n">user_service</span><span class="p">:</span> <span class="n">UserService</span><span class="p">,</span> <span class="n">page</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">user_service</span><span class="o">.</span><span class="n">list</span><span class="p">(</span><span class="n">page</span><span class="o">=</span><span class="n">page</span><span class="p">)</span>
</code></pre></div>

<p>How it works:</p>
<ol>
<li>The decorator inspects the function&rsquo;s signature.</li>
<li>For each parameter, it attempts to resolve the type from the container.</li>
<li>Parameters that <strong>can</strong> be resolved are pre-filled automatically.</li>
<li>Parameters that <strong>cannot</strong> be resolved remain as normal function parameters.</li>
<li>The function&rsquo;s <code>__signature__</code> is updated to reflect only the remaining parameters.</li>
</ol>
<p>In the example above, <code>user_service</code> is injected by the container while <code>page</code> remains a normal parameter.</p>
<div class="callout note">
<strong>Note</strong>
<p>Dependencies are resolved at <strong>call time</strong>, not at decoration time. This means mocks set after the decorator is applied will still be picked up.</p>
</div>
<h2 id="provide" class="section-anchor">Providing Dependencies</h2>
<p>You can also request dependencies directly without using the decorator:</p>
<div class="highlight"><pre><span></span><code><span class="n">service</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="n">UserService</span><span class="p">)</span>
</code></pre></div>

<p>This is useful for programmatic access to dependencies, such as in application setup code, background workers, or management commands.</p>
<p>If the type cannot be resolved, an <code>UnknownDependencyError</code> is raised.</p>
<h2 id="singleton" class="section-anchor">Global Singleton</h2>
<p>The <code>singleton()</code> helper creates or retrieves a globally shared instance. It is designed for use inside factory methods to ensure a single instance is shared across all threads.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">pysyringe.singleton</span><span class="w"> </span><span class="kn">import</span> <span class="n">singleton</span>


<span class="k">class</span><span class="w"> </span><span class="nc">DatabaseClient</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection_string</span> <span class="o">=</span> <span class="n">connection_string</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Factory</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_database</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatabaseClient</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">singleton</span><span class="p">(</span><span class="n">DatabaseClient</span><span class="p">,</span> <span class="s2">&quot;postgresql://localhost:5432/mydb&quot;</span><span class="p">)</span>


<span class="n">container</span> <span class="o">=</span> <span class="n">Container</span><span class="p">(</span><span class="n">Factory</span><span class="p">())</span>

<span class="n">client1</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="n">DatabaseClient</span><span class="p">)</span>
<span class="n">client2</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="n">DatabaseClient</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">client1</span> <span class="ow">is</span> <span class="n">client2</span>  <span class="c1"># Same instance everywhere</span>
</code></pre></div>

<p>The cache key includes the class, positional arguments, and keyword arguments (order-independent for keywords). Different arguments produce different instances.</p>
<p>Creation is <strong>thread-safe</strong> using double-checked locking&mdash;concurrent threads will never produce duplicate instances for the same key.</p>
<p>Best for: connection pools, HTTP clients, configuration objects, and other thread-safe resources that should be shared globally.</p>
<h2 id="thread-local-singleton" class="section-anchor">Thread-Local Singleton</h2>
<p>The <code>thread_local_singleton()</code> helper creates or retrieves a per-thread instance. Each thread gets its own instance; within the same thread, repeated calls return the same object.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">pysyringe.singleton</span><span class="w"> </span><span class="kn">import</span> <span class="n">thread_local_singleton</span>


<span class="k">class</span><span class="w"> </span><span class="nc">DatabaseSession</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dsn</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dsn</span> <span class="o">=</span> <span class="n">dsn</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Factory</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_session</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatabaseSession</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">thread_local_singleton</span><span class="p">(</span><span class="n">DatabaseSession</span><span class="p">,</span> <span class="s2">&quot;postgresql://localhost/mydb&quot;</span><span class="p">)</span>
</code></pre></div>

<p>Best for: database sessions, request-scoped state, and other resources that are not thread-safe and should not be shared across threads.</p>
<table>
<thead>
<tr>
<th>Helper</th>
<th>Scope</th>
<th>Thread Safety</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>singleton()</code></td>
<td>Global</td>
<td>Double-checked locking</td>
<td>Connection pools, HTTP clients</td>
</tr>
<tr>
<td><code>thread_local_singleton()</code></td>
<td>Per-thread</td>
<td>Thread-local storage</td>
<td>Database sessions, request state</td>
</tr>
</tbody>
</table>
<h2 id="mocks" class="section-anchor">Mocks &amp; Overrides</h2>
<p>PySyringe makes it easy to replace dependencies in tests. The recommended approach uses the <code>override()</code> context manager.</p>
<h3 id="override-context" class="section-anchor">Override Context Manager</h3>
<p>The <code>override()</code> and <code>overrides()</code> context managers temporarily replace dependencies for the duration of a <code>with</code> block. When the block exits, the original behavior is automatically restored.</p>
<h4 id="single-dependency">Single dependency</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">test_user_signup</span><span class="p">():</span>
    <span class="n">mock_repo</span> <span class="o">=</span> <span class="n">InMemoryUserRepository</span><span class="p">()</span>

    <span class="k">with</span> <span class="n">container</span><span class="o">.</span><span class="n">override</span><span class="p">(</span><span class="n">UserRepository</span><span class="p">,</span> <span class="n">mock_repo</span><span class="p">):</span>
        <span class="n">service</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="n">SignupUserService</span><span class="p">)</span>
        <span class="n">service</span><span class="o">.</span><span class="n">signup</span><span class="p">(</span><span class="s2">&quot;Jane&quot;</span><span class="p">,</span> <span class="s2">&quot;jane@example.org&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">mock_repo</span><span class="o">.</span><span class="n">get_by_email</span><span class="p">(</span><span class="s2">&quot;jane@example.org&quot;</span><span class="p">)</span>
</code></pre></div>

<h4 id="multiple-dependencies">Multiple dependencies</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">test_with_multiple_overrides</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">container</span><span class="o">.</span><span class="n">overrides</span><span class="p">({</span>
        <span class="n">UserRepository</span><span class="p">:</span> <span class="n">InMemoryUserRepository</span><span class="p">(),</span>
        <span class="n">EmailSender</span><span class="p">:</span> <span class="n">FakeEmailSender</span><span class="p">(),</span>
    <span class="p">}):</span>
        <span class="n">service</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="n">SignupUserService</span><span class="p">)</span>
        <span class="n">service</span><span class="o">.</span><span class="n">signup</span><span class="p">(</span><span class="s2">&quot;Jane&quot;</span><span class="p">,</span> <span class="s2">&quot;jane@example.org&quot;</span><span class="p">)</span>
</code></pre></div>

<div class="callout note">
<strong>Recommended</strong>
<p>Prefer <code>override()</code> / <code>overrides()</code> over the legacy <code>use_mock()</code> API. Context managers guarantee cleanup, preventing mock leakage between tests.</p>
</div>
<h3 id="legacy-mocks" class="section-anchor">Legacy Mock API</h3>
<p>The <code>use_mock()</code> and <code>clear_mocks()</code> methods provide a manual mock API. You are responsible for clearing mocks after each test.</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">autouse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">clear_container_mocks</span><span class="p">():</span>
    <span class="k">yield</span>
    <span class="n">container</span><span class="o">.</span><span class="n">clear_mocks</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">test_user_signup</span><span class="p">():</span>
    <span class="n">container</span><span class="o">.</span><span class="n">use_mock</span><span class="p">(</span><span class="n">UserRepository</span><span class="p">,</span> <span class="n">InMemoryUserRepository</span><span class="p">())</span>
    <span class="n">service</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="n">SignupUserService</span><span class="p">)</span>
    <span class="n">service</span><span class="o">.</span><span class="n">signup</span><span class="p">(</span><span class="s2">&quot;Jane&quot;</span><span class="p">,</span> <span class="s2">&quot;jane@example.org&quot;</span><span class="p">)</span>
</code></pre></div>

<h2 id="thread-safety" class="section-anchor">Thread Safety</h2>
<p>PySyringe is designed with thread safety in mind:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Scope</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>alias()</code></td>
<td>Global</td>
<td>Shared across all threads. Configure at startup.</td>
</tr>
<tr>
<td><code>never_provide()</code></td>
<td>Global</td>
<td>Shared across all threads. Configure at startup.</td>
</tr>
<tr>
<td>Factory methods</td>
<td>Global</td>
<td>Indexed at container initialization. Shared across threads.</td>
</tr>
<tr>
<td><code>use_mock()</code></td>
<td>Per-thread</td>
<td>Stored in thread-local storage. No cross-thread leakage.</td>
</tr>
<tr>
<td><code>clear_mocks()</code></td>
<td>Per-thread</td>
<td>Clears only the current thread&rsquo;s mocks.</td>
</tr>
<tr>
<td><code>singleton()</code></td>
<td>Global</td>
<td>Thread-safe creation via double-checked locking.</td>
</tr>
<tr>
<td><code>thread_local_singleton()</code></td>
<td>Per-thread</td>
<td>One instance per thread via <code>threading.local()</code>.</td>
</tr>
</tbody>
</table>
<p>Implications:</p>
<ul>
<li>Calling <code>use_mock(SomeType, mock)</code> in one thread does not affect other threads.</li>
<li>Calling <code>clear_mocks()</code> clears only the current thread&rsquo;s mocks.</li>
<li>To share behavior globally, use <code>alias()</code> or a factory method instead of mocks.</li>
</ul>
<h2 id="resolution-cache" class="section-anchor">Resolution Cache</h2>
<p>PySyringe includes a lightweight cache to speed up dependency resolution without affecting instance semantics.</p>
<h4 id="what-is-cached">What is cached</h4>
<ul>
<li>A precomputed map of factory methods keyed by their return type, built once at container initialization for O(1) lookups.</li>
<li>Constructor parameter introspection, cached via <code>functools.lru_cache</code> (512 entries) to avoid repeated signature parsing.</li>
</ul>
<h4 id="what-is-not-cached">What is NOT cached</h4>
<ul>
<li><strong>Instances.</strong> Each call to <code>provide()</code> creates a fresh instance unless you use <code>singleton()</code> or <code>thread_local_singleton()</code> in your factory.</li>
</ul>
<p>This means your singleton semantics, custom sharing strategies, and factory logic remain fully in your control. The cache only reduces the overhead of figuring out <em>how</em> to construct dependencies.</p>
<h2 id="optional-types" class="section-anchor">Optional &amp; Union Types</h2>
<p>PySyringe handles Optional and Union types as follows:</p>
<h4 id="optional-types_1">Optional types</h4>
<p><code>Optional[T]</code> (or <code>T | None</code>) is automatically unwrapped. The container resolves the non-None type.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Service</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logger</span><span class="p">:</span> <span class="n">Logger</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>

<span class="c1"># The container resolves Logger for the logger parameter.</span>
<span class="c1"># If Logger cannot be resolved, it uses the default value (None).</span>
</code></pre></div>

<h4 id="union-types">Union types</h4>
<p>Non-Optional union types like <code>A | B</code> are <strong>not supported</strong> and will raise an <code>UnresolvableUnionTypeError</code>. The container cannot determine which type to provide when multiple options exist.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Service</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store</span><span class="p">:</span> <span class="n">RedisStore</span> <span class="o">|</span> <span class="n">MemoryStore</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

<span class="c1"># Raises UnresolvableUnionTypeError</span>
<span class="c1"># Solution: use an alias or define a factory method instead.</span>
</code></pre></div>

<h2 id="errors" class="section-anchor">Error Handling</h2>
<p>PySyringe raises clear exceptions when resolution fails:</p>
<h4 id="unknowndependencyerror">UnknownDependencyError</h4>
<p>Raised when <code>container.provide(SomeType)</code> cannot resolve the requested type through any strategy (mocks, aliases, factory, or inference).</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">pysyringe.container</span><span class="w"> </span><span class="kn">import</span> <span class="n">UnknownDependencyError</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">container</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="n">SomeUnknownType</span><span class="p">)</span>
<span class="k">except</span> <span class="n">UnknownDependencyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>  <span class="c1"># &quot;Container does not know how to provide &lt;class &#39;SomeUnknownType&#39;&gt;&quot;</span>
</code></pre></div>

<h4 id="unresolvableuniontypeerror">UnresolvableUnionTypeError</h4>
<p>Raised during resolution when a constructor parameter uses a non-Optional union type like <code>A | B</code>.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">pysyringe.container</span><span class="w"> </span><span class="kn">import</span> <span class="n">UnresolvableUnionTypeError</span>
<span class="c1"># &quot;Cannot resolve [A | B]: remove UnionType or define a factory&quot;</span>
</code></pre></div>

<h2 id="api-container" class="section-anchor">Container API</h2>
<h3 id="containerfactorynone" class="section-anchor">Container(factory=None)</h3>
<p><code class="api-signature">Container(factory: object | None = None)</code></p>
<p>Create a new dependency injection container.</p>
<table class="param-table">
<thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead>
<tbody>
<tr><td>factory</td><td>object | None</td><td>An optional factory object. Public methods with return-type annotations are indexed as factory methods. If <code>None</code>, the container uses inference only.</td></tr>
</tbody>
</table>

<h3 id="containerprovidecls" class="section-anchor">container.provide(cls)</h3>
<p><code class="api-signature">provide(cls: type[T]) -&gt; T</code></p>
<p>Resolve and return an instance of the requested type. Raises <code>UnknownDependencyError</code> if the type cannot be resolved.</p>
<table class="param-table">
<thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead>
<tbody>
<tr><td>cls</td><td>type[T]</td><td>The type to resolve.</td></tr>
</tbody>
</table>

<h3 id="containerinjectfunction" class="section-anchor">container.inject(function)</h3>
<p><code class="api-signature">inject(function: Callable) -&gt; Callable</code></p>
<p>Decorator that injects resolvable dependencies into a function. Returns a wrapped function with resolved parameters pre-filled. Unresolvable parameters remain as normal parameters. The returned function&rsquo;s <code>__signature__</code> is updated to reflect only the remaining parameters.</p>
<table class="param-table">
<thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead>
<tbody>
<tr><td>function</td><td>Callable</td><td>The function to decorate.</td></tr>
</tbody>
</table>

<h3 id="containeraliasinterface-implementation" class="section-anchor">container.alias(interface, implementation)</h3>
<p><code class="api-signature">alias(interface: type, implementation: type) -&gt; None</code></p>
<p>Map an interface type to a concrete implementation. When the interface is requested, the container resolves the implementation instead (via inference).</p>
<table class="param-table">
<thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead>
<tbody>
<tr><td>interface</td><td>type</td><td>The abstract type or interface.</td></tr>
<tr><td>implementation</td><td>type</td><td>The concrete type to use.</td></tr>
</tbody>
</table>

<h3 id="containernever_providecls" class="section-anchor">container.never_provide(cls)</h3>
<p><code class="api-signature">never_provide(cls: type[T]) -&gt; None</code></p>
<p>Blacklist a type so the container will never attempt to resolve it. Useful for framework types like HTTP request/response objects.</p>
<table class="param-table">
<thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead>
<tbody>
<tr><td>cls</td><td>type[T]</td><td>The type to blacklist.</td></tr>
</tbody>
</table>

<h3 id="containeroverridecls-mock" class="section-anchor">container.override(cls, mock)</h3>
<p><code class="api-signature">@contextmanager override(cls: type[T], mock: T) -&gt; Iterator[None]</code></p>
<p>Context manager that temporarily replaces a single dependency. The original behavior is restored when the <code>with</code> block exits.</p>
<table class="param-table">
<thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead>
<tbody>
<tr><td>cls</td><td>type[T]</td><td>The type to override.</td></tr>
<tr><td>mock</td><td>T</td><td>The replacement instance.</td></tr>
</tbody>
</table>

<h3 id="containeroverridesoverride_map" class="section-anchor">container.overrides(override_map)</h3>
<p><code class="api-signature">@contextmanager overrides(override_map: dict[type[T], T]) -&gt; Iterator[None]</code></p>
<p>Context manager that temporarily replaces multiple dependencies at once.</p>
<table class="param-table">
<thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead>
<tbody>
<tr><td>override_map</td><td>dict[type, object]</td><td>A mapping of types to their replacement instances.</td></tr>
</tbody>
</table>

<h3 id="containeruse_mockcls-mock" class="section-anchor">container.use_mock(cls, mock)</h3>
<p><code class="api-signature">use_mock(cls: type[T], mock: T) -&gt; None</code></p>
<p>Set a mock for a type in the current thread. Thread-local: does not affect other threads. Prefer <code>override()</code> for new code.</p>
<table class="param-table">
<thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead>
<tbody>
<tr><td>cls</td><td>type[T]</td><td>The type to mock.</td></tr>
<tr><td>mock</td><td>T</td><td>The mock instance.</td></tr>
</tbody>
</table>

<h3 id="containerclear_mocks" class="section-anchor">container.clear_mocks()</h3>
<p><code class="api-signature">clear_mocks() -&gt; None</code></p>
<p>Clear all mocks for the current thread. Only affects the calling thread.</p>
<h2 id="api-singleton" class="section-anchor">Singleton API</h2>
<h3 id="singletontype_-args-kwargs" class="section-anchor">singleton(type_, <em>args, </em>*kwargs)</h3>
<p><code class="api-signature">singleton(type_: type[T], <em>type_args, </em>*type_kwargs) -&gt; T</code></p>
<p>Create or retrieve a globally shared singleton instance. Thread-safe via double-checked locking. The cache key is the combination of the class, positional args, and keyword args.</p>
<table class="param-table">
<thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead>
<tbody>
<tr><td>type_</td><td>type[T]</td><td>The class to instantiate.</td></tr>
<tr><td>*type_args</td><td>Any</td><td>Positional arguments for the constructor.</td></tr>
<tr><td>**type_kwargs</td><td>Any</td><td>Keyword arguments for the constructor.</td></tr>
</tbody>
</table>

<h3 id="thread_local_singletontype_-args-kwargs" class="section-anchor">thread_local_singleton(type_, <em>args, </em>*kwargs)</h3>
<p><code class="api-signature">thread_local_singleton(type_: type[T], <em>type_args, </em>*type_kwargs) -&gt; T</code></p>
<p>Create or retrieve a per-thread singleton instance. Each thread gets its own instance; within the same thread, repeated calls return the same object. Uses <code>threading.local()</code> for storage.</p>
<table class="param-table">
<thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead>
<tbody>
<tr><td>type_</td><td>type[T]</td><td>The class to instantiate.</td></tr>
<tr><td>*type_args</td><td>Any</td><td>Positional arguments for the constructor.</td></tr>
<tr><td>**type_kwargs</td><td>Any</td><td>Keyword arguments for the constructor.</td></tr>
</tbody>
</table>

<h2 id="api-exceptions" class="section-anchor">Exceptions</h2>
<h3 id="unknowndependencyerror_1" class="section-anchor">UnknownDependencyError</h3>
<p><code class="api-signature">class UnknownDependencyError(Exception)</code></p>
<p>Raised when <code>container.provide()</code> cannot resolve the requested type.</p>
<p>Message format: <code>"Container does not know how to provide &lt;type&gt;"</code></p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">pysyringe.container</span><span class="w"> </span><span class="kn">import</span> <span class="n">UnknownDependencyError</span>
</code></pre></div>

<h3 id="unresolvableuniontypeerror_1" class="section-anchor">UnresolvableUnionTypeError</h3>
<p><code class="api-signature">class UnresolvableUnionTypeError(Exception)</code></p>
<p>Raised when a constructor parameter uses a non-Optional union type (e.g. <code>A | B</code>) that the container cannot disambiguate.</p>
<p>Message format: <code>"Cannot resolve [type]: remove UnionType or define a factory"</code></p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">pysyringe.container</span><span class="w"> </span><span class="kn">import</span> <span class="n">UnresolvableUnionTypeError</span>
</code></pre></div>

</main>
</div>

<script>
(function() {
  var saved = localStorage.getItem('theme');
  if (saved) document.documentElement.setAttribute('data-theme', saved);
  function update() {
    var isDark = document.documentElement.getAttribute('data-theme') === 'dark' ||
      (!document.documentElement.getAttribute('data-theme') && window.matchMedia('(prefers-color-scheme: dark)').matches);
    document.querySelector('.theme-toggle').textContent = isDark ? '\u2600\uFE0F' : '\uD83C\uDF19';
  }
  document.addEventListener('DOMContentLoaded', update);
  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', update);
  window.toggleTheme = function() {
    var current = document.documentElement.getAttribute('data-theme');
    var isDark;
    if (current) {
      isDark = current === 'dark';
    } else {
      isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    }
    var next = isDark ? 'light' : 'dark';
    document.documentElement.setAttribute('data-theme', next);
    localStorage.setItem('theme', next);
    update();
  };
})();

function switchVersion(path) {
  if (path) window.location.href = path;
}

function toggleSidebar() {
  document.querySelector('.sidebar').classList.toggle('open');
  document.querySelector('.overlay').classList.toggle('open');
}

// Active link highlighting
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const id = entry.target.id;
      document.querySelectorAll('.sidebar a').forEach(a => {
        a.classList.toggle('active', a.getAttribute('href') === '#' + id);
      });
    }
  });
}, { rootMargin: '-80px 0px -80% 0px' });

document.querySelectorAll('.section-anchor').forEach(el => observer.observe(el));

// Close sidebar on link click (mobile)
document.querySelectorAll('.sidebar a').forEach(a => {
  a.addEventListener('click', () => {
    document.querySelector('.sidebar').classList.remove('open');
    document.querySelector('.overlay').classList.remove('open');
  });
});
</script>

</body>
</html>
